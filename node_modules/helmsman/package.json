{
  "name": "helmsman",
  "version": "0.2.6",
  "description": "Easily make command line interfaces using git style subcommands",
  "homepage": "https://github.com/mattmcmanus/node-helmsman",
  "author": {
    "name": "Matt McManus",
    "email": "mcmanus@punkave.com"
  },
  "contributors": [
    {
      "name": "Beau Gunderson",
      "email": "beau@beaugunderson.com",
      "url": "https://beaugunderson.com/"
    }
  ],
  "main": "helmsman.js",
  "scripts": {
    "test": "tap test"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:mattmcmanus/node-helmsman.git"
  },
  "bugs": {
    "url": "https://github.com/mattmcmanus/node-helmsman/issues"
  },
  "keywords": [
    "cli",
    "command",
    "subcommand",
    "sub-command"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/mattmcmanus/node-helmsman/blob/master/LICENSE-MIT"
    }
  ],
  "devDependencies": {
    "tap": "~0.4.3"
  },
  "dependencies": {
    "glob": "~3.2.1",
    "colors": "~0.6.0-1",
    "underscore.string": "~2.3.1"
  },
  "readme": "# node-helmsman\n\nEasily make command line interfaces using git style subcommands executables\n\n## So what does helmsman actually do?\n\nA common setup for command line applications is `<command> <subcommand> <arguments/options>` (for example: `git commit -m 'message'`). Rather than having a giant file that `switch`es or `if else`s over each potential subcommand, it's much neater to store each subcommand in it's own file (`bin/command`,`bin/command-subcomand`, `bin/command-subcommand2`, etc). Helmsman makes it easy to add, modify or delete subcommands without having to do housekeeping steps in your root command file or `package.json`\n\n### Features\n\n* Helmsman is automatically aware of all the `<command>-<subcommand>` files in your modules `bin/` (or any folder you tell it to look at)\n* `<command> --help` automatically generates help output, telling you all the subcommands that are available to you\n* `<command> --version` prints the version from package.json of the module requiring helmsman\n* Running `<command> <subcommand>` automatically executes the `<command>-<subcommand>` file, passing along all the arguments & options\n* Helmsman is capable of smart command completion including dynamic shorthands and spelling correction (eg: `<command> st` => `<command> status` or `<command> isntall` => `<command> install` )\n* Use whatever option parsing library you want for your subcommands ([optimist](https://github.com/substack/node-optimist), [commander](https://github.com/visionmedia/commander.js), etc)\n* Helmsman is [minimally intrusive in your subcommands](#setting-up-your-sub-commands-command-subcommand)\n\n## Installation & Setup\n\nIn your command line application folder:\n\n```\nnpm install helmsman --save\n```\n\n### Setting up your main executable: `<command>`\n\nIn your main executable, add `helmsman`:\n\n```javascript\n#!/usr/bin/env node\n\nvar helmsman = require('helmsman');\n\nhelmsman().parse();\n```\n\nWant to append in additional help messaging or modify the arguments that are parsed?\n\n```javascript\n#!/usr/bin/env node\n\nvar helmsman = require('helmsman');\n\nvar cli = helmsman()\n\ncli.on('--help', function(){\n  console.log('EXTRA HELPFUL!');\n});\n\nvar argv = process.argv;\n\nargv.push('--pizza');\n\n// parse() can accept modified arguments, otherwise it defaults to process.argv\ncli.parse(argv);\n```\n\n### Setting up your sub-commands: `<command>-<subcommand>`\n\nFor your sub-executables to work with `helmsman` you need to do two things: 1. Expose metadata about the task, like its description and 2. Make sure the meat & potatoes of the script only runs when it's directly called\n\n```javascript\n#!/usr/bin/env node\n\n// 1. Expose the metadata\nexports.command = {\n  description: 'Show current worker counts and their pids'\n};\n\n// 2. Make sure it only runs when it's directly called:\nif (require.main === module) {\n  // Parse options and run the magic\n}\n```\n\n**Note:** If you're not putting each script in `package.json`'s `bin` object, make sure that the sub-commands are executable by running `chmod +x bin/<command>-<sub-command>\n\n## API\n\n### helmsman([options]) or new Helmsman([options])\n\n* `options` {Object}\n\nCreate an instance of `helmsman`. It is an `EventEmitter` and will also begin searching for files once it's instantiated. \n\n#### Events\n\n* `--help`: Emitted when `--help` is passed as the first option or no commands or options are passed\n\n#### Options\n\n* `localDir`: The local module folder where to search for executable files. Defaults to the directory of the executable (eg: If you execute `<module folder>/bin/<command>` the `localDir` will be `<module folder>/bin`)\n* `prefix`: The prefix of the subcommands to search for. Defaults to the executed file (eg: If you run `<command>` it will search for files in the `localDir` that start with `<command>-`\n\n#### Methods\n\n* `parse([argv])` Parse `argv` or `process.argv` if there is no argv and either display the help or run the subcommand\n\n### <subcommand> `exports.command`\n\n* `description`: A one line description of the command. Required.\n* `arguments`: A shorthand for options the subcommand accepts. Generated help will include it next to command. See `help <command>`\"\n\n## TODO\n\n* [Allow for automatically including npm installed libraries](https://github.com/mattmcmanus/node-helmsman/issues/2)\n\n## Thanks\n\nMuch of this was inspired by TJ Holowaychuk's [commander](https://github.com/visionmedia/commander.js) and [component](https://github.com/component/component)\n",
  "readmeFilename": "README.md",
  "_id": "helmsman@0.2.6",
  "_from": "helmsman@~0.2.6"
}
